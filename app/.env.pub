#!/bin/bash

NORMAL=$(echo -e '\033[0m')
RED=$(echo -e '\033[31m')
GREEN=$(echo -e '\033[0;32m')
LGREEN=$(echo -e '\033[1;32m')
BLUE=$(echo -e '\033[0;34m')
LBLUE=$(echo -e '\033[1;34m')
YELLOW=$(echo -e '\033[0;33m')
PURPLE=$'\033[0;35m'
NC=$'\033[0m'

## aliases:
alias k='kubectl'
alias tf='terraform'
alias ll='ls -lahGF --group-directories-first --sort=extension'
alias ll_time='ls -lahGF --group-directories-first --sort=time'

###########################

### SSH ###############
  enable_proxy() {
    export socks_proxy_ip=127.0.0.1
    export socks_proxy_port=8888
    export socks_proxy="socks://$socks_proxy_ip:$socks_proxy_port"
    export all_proxy=$socks_proxy
  }

  ssh_auth_log() {
    #!/bin/bash

    if [[ $EUID -ne 0 ]]; then
      echo "‚ö†Ô∏è  Please run as root to access full authentication logs"
      exit 1
    fi

    echo "üìã SSH Login Summary"
    echo "-----------------------------------------------"
    echo "TIME                  | IP            | USER         | STATUS"
    echo "-----------------------------------------------"

    if [[ -f "/var/log/auth.log" ]]; then
      # for ubuntu/debian systems
      log_file="/var/log/auth.log"
    elif [[ -f "/var/log/secure" ]]; then
      # for centos/redhat systems
      log_file="/var/log/secure"
    else
      echo "‚ùå No known SSH auth log found"
      exit 1
    fi

    # Load logs
    if [[ -f "$log_file" ]]; then
      log_data=$(grep -E "sshd.*(Failed|Accepted|Invalid user|Connection closed by)" "$log_file")
    elif command -v journalctl &>/dev/null; then
      log_data=$(journalctl -u ssh --no-pager | grep -E "sshd.*(Failed|Accepted|Invalid user|Connection closed by)")
    else
      echo "‚ùå No valid log source found"
      exit 1
    fi

    # Temp files for aggregation
    tmp_full_log=$(mktemp)
    tmp_failed_by_ip=$(mktemp)
    tmp_failed_by_user=$(mktemp)

    # Parse each line
    echo "$log_data" | while read -r line; do
      time=$(echo "$line" | awk '{print $1, $2, $3}')
      ip=$(echo "$line" | grep -oP '([0-9]{1,3}\.){3}[0-9]{1,3}')
      port=$(echo "$line" | grep -oP '(?<=port )\d+')

      if echo "$line" | grep -q "Accepted"; then
        status="SUCCESS"
        user=$(echo "$line" | grep -oP '(?<=for )[a-zA-Z0-9._-]+(?= from)')

      elif echo "$line" | grep -q "Failed password"; then
        status="FAILED"
        user=$(echo "$line" | grep -oP '(?<=for (invalid user )?)[a-zA-Z0-9._-]+(?= from)')
        echo "$ip" >>"$tmp_failed_by_ip"
        echo "$user" >>"$tmp_failed_by_user"

      elif echo "$line" | grep -q "Invalid user"; then
        status="INVALID_USER"
        user=$(echo "$line" | grep -oP '(?<=Invalid user )[a-zA-Z0-9._-]+')
        echo "$ip" >>"$tmp_failed_by_ip"
        echo "$user" >>"$tmp_failed_by_user"

      elif echo "$line" | grep -q "Connection closed by"; then
        status="CONNECTION_CLOSED"
        user=$(echo "$line" | grep -oP '(?<=user )[a-zA-Z0-9._-]+')
        [[ -z "$user" ]] && user="unknown"
      else
        continue
      fi

      printf "%-20s | %-13s | %-12s | %-18s\n" "$time" "$ip" "$user" "$status" >>"$tmp_full_log"
    done

    # Display all parsed events
    cat "$tmp_full_log"

    echo ""
    echo "üî¢ Failed or Invalid Attempts by IP:"
    echo "------------------------------------"
    sort "$tmp_failed_by_ip" | uniq -c | sort -nr | awk '{printf "%-5s %s\n", $1, $2}'

    echo ""
    echo "üî¢ Failed or Invalid Attempts by User:"
    echo "--------------------------------------"
    sort "$tmp_failed_by_user" | uniq -c | sort -nr | awk '{printf "%-5s %s\n", $1, $2}'

    # Cleanup
    rm -f "$tmp_full_log" "$tmp_failed_by_ip" "$tmp_failed_by_user"

  }

#######################

### GIT ###############
  alias gp='git pull'
  alias gs='git status'
  gb() { git branch "$@"; }
  gp_all() {
    # Find all directories that contain a .git folder and execute git pull
    find . -type d -name ".git" | while read git_dir; do
      repo_dir=$(dirname "$git_dir")

      printf "${PURPLE}[${repo_dir}]${NC}\n"

      # Navigate to repo directory and pull the latest changes
      (cd "$repo_dir" && git pull)
    done
  }
  ## git location:
  parse_git_branch() {
    git branch 2>/dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/(\1)/'
  }
#######################

### bash custom #######
  # and get current k8s context:
  parse_eks_context() {
    kubectl config current-context 2>/dev/null | sed "s/arn:aws:eks://g"
  }
  export PS1="${GREEN}\w ${RED}\$(parse_git_branch)${NORMAL}\n${YELLOW}\u${RED}@\H${NORMAL}\n[\$(date +%R)] \$ "
  FOR_k8S="\[\e[1:49:94m\]\$(parse_eks_context)$\[\e[00m\] $PS1"

#######################

### k8s ###############
  alias kcgc='kubectl config get-contexts'
  kcuc() { kubectl config use-context "$1"; }
  k_set_namespace() { kubectl config set-context --current --namespace="$1"; }
  # to clear the context:
  k_clear() { kubectl config unset current-context >/dev/null; }

  alias kgns='kubectl get namespaces'
  alias kgno='kubectl get nodes -o wide'
  alias kdno='kubectl describe nodes'
  keit_bash() { kubectl exec -it "$@" -- /bin/bash; }
  keit_sh() { kubectl exec -it "$@" -- /bin/sh; }
  kgsvc() { kubectl get service -o wide "$@"; }
  kgscr() { kubectl get secrets -o wide "$@"; }
  kgp() { kubectl get pods -o wide "$@"; }
  kdp() { kubectl delete pod "$@"; }
  kgd() { kubectl get deployments "$@"; }
  kgi() { kubectl get ingress -o wide "$@"; }
  kga() { kubectl get all -o wide --show-labels "$@"; }
  kge() { kubectl get events --sort-by='.lastTimestamp' "$@"; }
  kgc() { kubectl get certificate "$@"; }
  kgcr() { kubectl get certificaterequest "$@"; }
  kgo() { kubectl get order "$@"; }
  kgrq() { kubectl get resourcequota "$@"; }
  kerq() { kubectl edit resourcequota "$@"; }

  kgnp() { kubectl get networkpolicy "$@"; }
  kenp() { kubectl edit networkpolicy "$@"; }
  kdnp() { kubectl delete networkpolicy "$@"; }

  kgnp_calico() { kubectl get networkpolicies.projectcalico.org "$@"; }
  kenp_calico() { kubectl edit networkpolicies.projectcalico.org "$@"; }
  kdnp_calico() { kubectl delete networkpolicies.projectcalico.org "$@"; }

  #jobs
  kgj() { kubectl get jobs; }
  klj() { kubectl logs -l job-name="$1"; }
  #######################

  ####### Python ########
  py_env() { python3 -m venv py_env && source py_env/bin/activate; }
#######################

### Tools #############
  cheat() { curl "https://cheat.sh/$*"; }
  base64_d() { echo "$1" | base64 -d; }

  # Display info about the system:
  sys_info() {
    echo -e "System Information"
    echo -e "==================="
    echo -e "Hostname: $(hostname)"
    echo -e "Kernel: $(uname -r)"
    echo -e "OS: $(lsb_release -d | cut -f2-)"
    echo -e "Architecture: $(uname -m)"
    echo -e "Uptime: $(uptime -p)"
    lscpu | egrep 'Model name|CPU\(s\)|Core\(s\) per socket|Thread\(s\) per core|MHz'
  }
  # Display eth interface information:
  eth_info() {
    # Header
    printf "%-15s %-20s %-10s %-15s %-18s %-15s %-25s\n" \
      "Interface" "MAC Address" "Status" "Speed" "Bridge Port" "Bond Master" "Model"

    # Check for helper tools once
    local have_ethtool="" have_udevadm=""
    command -v ethtool &>/dev/null && have_ethtool=1
    command -v udevadm &>/dev/null && have_udevadm=1

    for iface_path in /sys/class/net/*; do
      local iface mac status speed bridge bond_master model

      iface=$(basename "$iface_path")

      # Skip loopback and docker-style veth interfaces
      [[ "$iface" == "lo" || "$iface" == veth* ]] && continue
      [[ ! -d "$iface_path" ]] && continue

      mac=$(cat "$iface_path/address" 2>/dev/null)
      status=$(cat "$iface_path/operstate" 2>/dev/null)

      # Speed info (if ethtool available)
      if [[ -n "$have_ethtool" ]] && ethtool "$iface" &>/dev/null; then
        speed=$(ethtool "$iface" | awk -F': ' '/Speed/ {print $2}')
        [[ -z "$speed" || "$speed" == "Unknown!" ]] && speed="Unknown"
      else
        speed="N/A"
      fi

      # Bridge port membership
      if [[ -e "$iface_path/brport/bridge" ]]; then
        bridge=$(basename "$(readlink "$iface_path/brport/bridge")")
      else
        bridge=""
      fi

      # Bond slave membership
      if [[ -e "$iface_path/bonding_slave/perm_hwaddr" ]]; then
        # Look for master symlink pointing to bond
        master_path=$(readlink -f "$iface_path/master" 2>/dev/null)
        bond_master=$(basename "$master_path")
      else
        bond_master=""
      fi

      # NIC model / driver info
      model=""

      # 1) Try udev properties (often has ID_MODEL_FROM_DATABASE like "Intel I210 Gigabit Network Connection")
      if [[ -n "$have_udevadm" ]]; then
        model=$(udevadm info -q property -p "$iface_path" 2>/dev/null | \
          awk -F'=' '
            /^ID_MODEL_FROM_DATABASE=/ {sub(/^ID_MODEL_FROM_DATABASE=/,""); print; exit}
            /^ID_MODEL=/ {sub(/^ID_MODEL=/,""); print; exit}
          ')
      fi

      # 2) Fallback to ethtool -i: driver + bus-info
      if [[ -z "$model" && -n "$have_ethtool" ]] && ethtool -i "$iface" &>/dev/null; then
        model=$(ethtool -i "$iface" 2>/dev/null | awk -F': ' '
          /^driver:/ {drv=$2}
          /^bus-info:/ {bus=$2}
          END {
            if (drv && bus) print drv " (" bus ")"
            else if (drv) print drv
          }
        ')
      fi

      # 3) Final fallback
      [[ -z "$model" ]] && model="Unknown"

      printf "%-15s %-20s %-10s %-15s %-18s %-15s %-25s\n" \
        "$iface" "$mac" "$status" "$speed" "$bridge" "$bond_master" "$model"
    done
  }

  # Display disk info:
  lsblk_info() {
    lsblk --output NAME,MODEL,SERIAL,STATE,PHY-SEC,LOG-SEC,SCHED,RQ-SIZE,RA,FSTYPE,FSVER,LABEL,UUID,MOUNTPOINTS
  }

#######################

### Certificates #####
  # get info about site certificate:
  cert_info() {
    local host="$1"
    local port="${2:-443}"

    if [[ -z "$host" ]]; then
      echo "Usage: cert_info <hostname> [port]" >&2
      return 1
    fi

    echo | \
      openssl s_client -showcerts -servername "$host" -connect "$host:$port" 2>/dev/null | \
      sed -n '/-----BEGIN CERTIFICATE-----/,/-----END CERTIFICATE-----/p' | \
      openssl x509 -noout -text
  }

  cert_save_pem() {
    local host="$1"
    local port="${2:-443}"
    local output_file="${3:-${host}_cert.pem}"

    if [[ -z "$host" ]]; then
      echo "Usage: cert_save_pem <hostname> [port] [output_file]" >&2
      return 1
    fi

    echo | \
      openssl s_client -showcerts -servername "$host" -connect "$host:$port" 2>/dev/null | \
      openssl x509 -outform PEM >"$output_file"

    echo "Certificate saved to $output_file"
  }  

  cert_save_chain() {
    local host="$1"
    local port="${2:-443}"
    local output_file="${3:-${host}_cert_chain.pem}"

    if [[ -z "$host" ]]; then
      echo "Usage: cert_save_chain <hostname> [port] [output_file]" >&2
      return 1
    fi

    echo | \
      openssl s_client -showcerts -servername "$host" -connect "$host:$port" 2>/dev/null | \
      sed -n '/-----BEGIN CERTIFICATE-----/,/-----END CERTIFICATE-----/p' >"$output_file"

    echo "Certificate chain saved to $output_file"
  }

  # Get all certificates issued for domain oncl subs:
  cert_issued_by_domain() { 
    curl -s "https://crt.sh/?q=$1&output=json" -o /tmp/crt.json
    jq -r '.[] | .name_value' /tmp/crt.json | sort -u; 
    rm -f /tmp/crt.json  
  }

  cert_actual_by_domain() {
    curl -s "https://crt.sh/?q=$1&output=json" -o /tmp/crt.json
    now=$(date -u +"%Y-%m-%dT%H:%M:%S")
    jq -r --arg now "$now" '.[] | select(.not_after > $now) | "\(.name_value) \(.not_after)"' /tmp/crt.json | sort -u
    rm -f /tmp/crt.json
  }

######################

### Proxmox ###########
  # Get lxc\kvm info about instances on the PVE node
  proxmox_instances_info() {
    TMP=$(mktemp)
    VLAN_PRESENT=0

    detect_vlan() {
      for vmid in $(pct list | awk 'NR>1 {print $1}'); do
        config="$(pct config "$vmid" 2>/dev/null)"
        if echo "$config" | grep -qP '^net\d+:.*tag='; then
          VLAN_PRESENT=1
          return
        fi
      done
      for vmid in $(qm list | awk 'NR>1 {print $1}'); do
        config="$(qm config "$vmid" 2>/dev/null)"
        if echo "$config" | grep -qP '^net\d+:.*tag='; then
          VLAN_PRESENT=1
          return
        fi
      done
    }

    detect_vlan

    if ((VLAN_PRESENT)); then
      printf_format="%-6s %-26s %-10s %-30s %-10s %-6s %-8s %-15s %-10s %-12s %-8s\n"
      printf "$printf_format" "Type" "Name" "Status" "IP Address(es)" "Bridge" "VLAN" "OnBoot" "Storage" "DiskSize" "VMID" "Note"
    else
      printf_format="%-6s %-26s %-10s %-30s %-10s %-8s %-15s %-10s %-12s %-8s\n"
      printf "$printf_format" "Type" "Name" "Status" "IP Address(es)" "Bridge" "OnBoot" "Storage" "DiskSize" "VMID" "Note"
    fi

    get_vlan() {
      local net_line="$1"
      local vlan=$(echo "$net_line" | grep -oP 'tag=\K[0-9]+')
      [[ -z "$vlan" ]] && vlan="-"
      echo "$vlan"
    }

    get_lxc_disk_size() {
      local config="$1"
      local size=$(echo "$config" | grep -oP '^rootfs:.*size=\K[0-9]+[GM]')
      [[ -z "$size" ]] && echo "0.0G" && return
      echo "$size" | sed 's/G$/\.0G/; s/M$/M/'
    }

    get_qemu_disk_size() {
      local vmid="$1"
      local total=0
      local tmpfile=$(mktemp)
      qm config "$vmid" >"$tmpfile"
      while IFS= read -r line; do
        case "$line" in
        virtio*:* | scsi*:* | sata*:* | ide*:*)
          [[ "$line" == *cloudinit* ]] && continue
          [[ "$line" == *media=cdrom* ]] && continue
          local vol=$(echo "$line" | cut -d' ' -f2 | cut -d',' -f1 | xargs)
          [[ -z "$vol" ]] && continue
          local storage="${vol%%:*}"
          local vol_id="${vol#*:}"
          if [[ "$storage" == "local-lvm" ]]; then
            local lv_path=$(lvs --noheadings -o lv_path | grep "/$vol_id" | xargs)
            if [[ -n "$lv_path" ]]; then
              local size=$(lvs --noheadings --units g -o lv_size "$lv_path" 2>/dev/null | awk '{gsub(/[[:space:]]|g/,""); print}')
              [[ -z "$size" ]] && size="0"
              total=$(echo "$total + $size" | bc)
            fi
          fi
          ;;
        esac
      done <"$tmpfile"
      rm -f "$tmpfile"
      printf "%.1fG\n" "$total"
    }

    get_lxc_info() {
      local vmid="$1"
      local config="$(pct config "$vmid" 2>/dev/null)"
      local name=$(echo "$config" | awk -F ': ' '/^hostname:/ {print $2}')
      local status=$(pct status "$vmid" | awk '{print $2}')
      local ip=$(echo "$config" | grep -oP 'ip=\K[^,]+' | paste -sd "," -)
      [[ -z "$ip" ]] && ip="N/A"
      local onboot=$(echo "$config" | awk -F ': ' '/^onboot:/ {print $2}')
      [[ -z "$onboot" ]] && onboot="no"
      local storage_vol=$(echo "$config" | grep -oP '^rootfs: \K[^,]+')
      local storage="${storage_vol%%:*}"
      [[ -z "$storage" ]] && storage="N/A"
      local disk_size=$(get_lxc_disk_size "$config")
      local net_line=$(echo "$config" | grep -m1 "^net")
      local bridge=$(echo "$net_line" | grep -oP 'bridge=\K[^,]+')
      [[ -z "$bridge" ]] && bridge="N/A"
      local vlan=$(get_vlan "$net_line")
      local note=$(echo "$config" | awk -F ': ' '/^description:/ {print $2}')
      [[ -z "$note" ]] && note="-"

      if ((VLAN_PRESENT)); then
        printf "$printf_format" "LXC" "$name" "$status" "$ip" "$bridge" "$vlan" "$onboot" "$storage" "$disk_size" "$vmid" "$note" >>"$TMP"
      else
        printf "$printf_format" "LXC" "$name" "$status" "$ip" "$bridge" "$onboot" "$storage" "$disk_size" "$vmid" "$note" >>"$TMP"
      fi
    }

    get_qemu_info() {
      local vmid="$1"
      local config="$(qm config "$vmid" 2>/dev/null)"
      local name=$(echo "$config" | awk -F ': ' '/^name:/ {print $2}')
      local status=$(qm status "$vmid" | awk '{print $2}')
      local onboot=$(echo "$config" | awk -F ': ' '/^onboot:/ {print $2}')
      [[ -z "$onboot" ]] && onboot="no"
      local disk_line=$(echo "$config" | grep -E '^(virtio|scsi|sata|ide)[0-9]+:')
      local storage_vol=$(echo "$disk_line" | grep -oP '^\w+0: \K[^,]+')
      local storage="${storage_vol%%:*}"
      [[ -z "$storage" ]] && storage="N/A"
      local disk_size=$(get_qemu_disk_size "$vmid")
      local ip_list="N/A"
      if [[ "$status" == "running" ]]; then
        ip_list=$(qm guest cmd "$vmid" network-get-interfaces 2>/dev/null |
          jq -r '.[]? | .["ip-addresses"][]? | select(.["ip-address"] | test("^[0-9.]+$")) | .["ip-address"]' |
          grep -v '^127\\.0\\.0\\.1$' | paste -sd "," -)
        [[ -z "$ip_list" ]] && ip_list="N/A"
      fi
      local net_line=$(echo "$config" | grep -m1 "^net")
      local bridge=$(echo "$net_line" | grep -oP 'bridge=\K[^,]+')
      [[ -z "$bridge" ]] && bridge="N/A"
      local vlan=$(get_vlan "$net_line")
      local note=$(echo "$config" | awk -F ': ' '/^(description|notes):/ {print $2}' | head -n1)
      [[ -z "$note" ]] && note="-"

      if ((VLAN_PRESENT)); then
        printf "$printf_format" "QEMU" "$name" "$status" "$ip_list" "$bridge" "$vlan" "$onboot" "$storage" "$disk_size" "$vmid" "$note" >>"$TMP"
      else
        printf "$printf_format" "QEMU" "$name" "$status" "$ip_list" "$bridge" "$onboot" "$storage" "$disk_size" "$vmid" "$note" >>"$TMP"
      fi
    }

    (
      job_count=0
      MAX_JOBS=15
      for vmid in $(pct list | awk 'NR>1 {print $1}'); do
        { get_lxc_info "$vmid"; } &>/dev/null &
        ((++job_count >= MAX_JOBS)) && wait && job_count=0
      done
      for vmid in $(qm list | awk 'NR>1 {print $1}'); do
        { get_qemu_info "$vmid"; } &>/dev/null &
        ((++job_count >= MAX_JOBS)) && wait && job_count=0
      done
      wait
    ) 2>/dev/null

    sort -k10n "$TMP"
    rm -f "$TMP"
  }

  # Get lxc\kvm info about instances in cluster
  proxmox_instances_info_all() {
    require_cmd() { command -v "$1" >/dev/null 2>&1 || { echo "Missing dependency: $1" >&2; exit 1; }; }
    require_cmd pvesh
    require_cmd jq
    require_cmd awk

    TMP_DATA=$(mktemp)      # tab-separated rows
    CACHE_DIR=$(mktemp -d)  # storage content cache per node/storage
    VLAN_PRESENT=0

    bytes_to_gib() { # prints like 12.3G
      awk -v b="$1" 'BEGIN { printf("%.1fG", b/1024/1024/1024) }'
    }

    # read .tags, normalize ; -> , and default to "-"
    normalize_tags() {
      local raw="$1"
      if [[ -z "$raw" || "$raw" == "null" ]]; then echo "-"; else echo "$raw" | tr -d '"' | tr ';' ','; fi
    }

    # cache storage content list to avoid repeated API calls
    cache_storage_content() {
      local node="$1" storage="$2"
      local cachefile="$CACHE_DIR/${node}__${storage}.json"
      if [[ ! -s "$cachefile" ]]; then
        local tmpf; tmpf=$(mktemp)
        if pvesh get "/nodes/$node/storage/$storage/content" --output-format json >"$tmpf" 2>/dev/null; then
          mv "$tmpf" "$cachefile"
        else
          rm -f "$tmpf"
          printf "[]\n" >"$cachefile"
        fi
      fi
      echo "$cachefile"
    }

    # sum disk sizes for a QEMU VM by looking up each volume in storage content
    qemu_disk_size_gib() {
      local node="$1" config_json="$2"
      # collect disk vol strings from config, skip cloudinit and cdrom
      mapfile -t vols < <(echo "$config_json" | jq -r '
        to_entries
        | map(select(.key|test("^(virtio|scsi|sata|ide)[0-9]+$")))
        | .[]
        | .value
        | select((test("cloudinit")|not) and (test("media=cdrom")|not))
        | split(",")[0]
      ')
      [[ ${#vols[@]} -eq 0 ]] && { echo "0.0G"; return; }

      local total_bytes=0
      for v in "${vols[@]}"; do
        local storage="${v%%:*}"
        local vol_id="${v#*:}"
        local cachefile; cachefile=$(cache_storage_content "$node" "$storage")
        # find matching volid and get .size in bytes
        local sz
        sz=$(jq -r --arg vid "${storage}:${vol_id}" '.[] | select(.volid==$vid) | .size' "$cachefile" 2>/dev/null)
        [[ -z "$sz" || "$sz" == "null" ]] && sz=0
        total_bytes=$(( total_bytes + sz ))
      done
      bytes_to_gib "$total_bytes"
    }

    # extract first bridge and vlan tag from any net* string in config
    parse_net_bridge_vlan() {
      local config_json="$1"
      local netlines
      netlines=$(echo "$config_json" | jq -r 'to_entries | map(select(.key|test("^net[0-9]+$")))[]?.value')
      local bridge vlan
      bridge=$(echo "$netlines" | grep -oP 'bridge=\K[^,]+' | head -n1)
      vlan=$(echo "$netlines" | grep -oP 'tag=\K[0-9]+' | head -n1)
      [[ -z "$bridge" ]] && bridge="N/A"
      [[ -z "$vlan" ]] && vlan="-"
      if [[ "$vlan" != "-" ]]; then VLAN_PRESENT=1; fi
      echo "$bridge|$vlan"
    }

    # LXC: write one TSV row: Type Node Name Status IPs Bridge VLAN OnBoot Storage DiskSize VMID Tags Note
    get_lxc_info() {
      local node="$1" vmid="$2"
      local cfg status_json
      cfg=$(pvesh get "/nodes/$node/lxc/$vmid/config" --output-format json 2>/dev/null) || return
      status_json=$(pvesh get "/nodes/$node/lxc/$vmid/status/current" --output-format json 2>/dev/null) || return

      local name onboot storage rootfs size bridge vlan tags note ip
      name=$(echo "$cfg" | jq -r '.hostname // "-"')
      onboot=$(echo "$cfg" | jq -r '.onboot // "0"')
      [[ "$onboot" == "1" || "$onboot" == "true" || "$onboot" == "yes" ]] && onboot="yes" || onboot="no"

      rootfs=$(echo "$cfg" | jq -r '.rootfs // ""')
      storage="${rootfs%%:*}"; [[ -z "$storage" ]] && storage="N/A"
      size=$(echo "$rootfs" | grep -oP 'size=\K[0-9]+[GM]' )
      [[ -z "$size" ]] && size="0.0G" || size=$(echo "$size" | sed 's/G$/\.0G/; s/M$/M/')

      IFS='|' read -r bridge vlan < <(parse_net_bridge_vlan "$cfg")
      tags=$(normalize_tags "$(echo "$cfg" | jq -r '.tags // empty')")
      note=$(echo "$cfg" | jq -r '.description // "-"')
      ip=$(echo "$cfg" | jq -r '
        [ to_entries[] | select(.key|test("^net[0-9]+$")) | .value
          | capture("ip=([^,]+)")?.[1]
        ] | map(select(. != null)) | join(",")
      ')
      [[ -z "$ip" ]] && ip="N/A"

      local status
      status=$(echo "$status_json" | jq -r '.status // "-"')

      printf "LXC\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n" \
        "$node" "$name" "$status" "$ip" "$bridge" "$vlan" "$onboot" "$storage" "$size" "$vmid" "$tags" "$note" >>"$TMP_DATA"
    }

    # QEMU: write one TSV row
    get_qemu_info() {
      local node="$1" vmid="$2"
      local cfg status_json
      cfg=$(pvesh get "/nodes/$node/qemu/$vmid/config" --output-format json 2>/dev/null) || return
      status_json=$(pvesh get "/nodes/$node/qemu/$vmid/status/current" --output-format json 2>/dev/null) || return

      local name onboot tags note status ip_list bridge vlan storage_primary
      name=$(echo "$cfg" | jq -r '.name // "-"')
      onboot=$(echo "$cfg" | jq -r '.onboot // "0"')
      [[ "$onboot" == "1" || "$onboot" == "true" || "$onboot" == "yes" ]] && onboot="yes" || onboot="no"

      tags=$(normalize_tags "$(echo "$cfg" | jq -r '.tags // empty')")
      note=$(echo "$cfg" | jq -r '(.description // .notes // "-")')

      status=$(echo "$status_json" | jq -r '.status // "-"')

      # IPs via guest agent; ignore failures and IPv6/loopback for brevity
      if [[ "$status" == "running" ]]; then
        ip_list=$(pvesh get "/nodes/$node/qemu/$vmid/agent/network-get-interfaces" --output-format json 2>/dev/null \
          | jq -r '.[]? | .["ip-addresses"][]? | .["ip-address"]' \
          | grep -E '^[0-9.]+$' | grep -v '^127\.0\.0\.1$' | paste -sd "," -)
        [[ -z "$ip_list" ]] && ip_list="N/A"
      else
        ip_list="N/A"
      fi

      IFS='|' read -r bridge vlan < <(parse_net_bridge_vlan "$cfg")

      # storage: show storage of first disk if any, else N/A
      storage_primary=$(echo "$cfg" | jq -r '
        to_entries
        | map(select(.key|test("^(virtio|scsi|sata|ide)[0-9]+$")))
        | map(.value|split(",")[0]|split(":")[0]) | .[0] // "N/A"
      ')

      local disksize
      disksize=$(qemu_disk_size_gib "$node" "$cfg")

      printf "QEMU\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n" \
        "$node" "$name" "$status" "$ip_list" "$bridge" "$vlan" "$onboot" "$storage_primary" "$disksize" "$vmid" "$tags" "$note" >>"$TMP_DATA"
    }

    # enumerate nodes
    mapfile -t NODES < <(pvesh get /nodes --output-format json | jq -r '.[].node')

    # gather data with some concurrency
    (
      job_count=0
      MAX_JOBS=15

      for node in "${NODES[@]}"; do
        # LXC
        mapfile -t LXCS < <(pvesh get "/nodes/$node/lxc" --output-format json 2>/dev/null | jq -r '.[].vmid')
        for vmid in "${LXCS[@]}"; do
          { get_lxc_info "$node" "$vmid"; } >/dev/null 2>&1 &
          (( ++job_count >= MAX_JOBS )) && wait && job_count=0
        done

        # QEMU
        mapfile -t VMS < <(pvesh get "/nodes/$node/qemu" --output-format json 2>/dev/null | jq -r '.[].vmid')
        for vmid in "${VMS[@]}"; do
          { get_qemu_info "$node" "$vmid"; } >/dev/null 2>&1 &
          (( ++job_count >= MAX_JOBS )) && wait && job_count=0
        done
      done
      wait
    )

    # sort by VMID (11th TSV column)
    sort -t $'\t' -k11,11n "$TMP_DATA" > "${TMP_DATA}.sorted"

    # headers and pretty print
    if (( VLAN_PRESENT )); then
      printf "%-6s %-10s %-26s %-10s %-30s %-10s %-6s %-8s %-15s %-10s %-12s %-14s %-8s\n" \
        "Type" "Node" "Name" "Status" "IP Address(es)" "Bridge" "VLAN" "OnBoot" "Storage" "DiskSize" "VMID" "Tags" "Note"
    else
      printf "%-6s %-10s %-26s %-10s %-30s %-10s %-8s %-15s %-10s %-12s %-14s %-8s\n" \
        "Type" "Node" "Name" "Status" "IP Address(es)" "Bridge" "OnBoot" "Storage" "DiskSize" "VMID" "Tags" "Note"
    fi

    while IFS=$'\t' read -r type node name status ip bridge vlan onboot storage disksize vmid tags note; do
      if (( VLAN_PRESENT )); then
        printf "%-6s %-10s %-26s %-10s %-30s %-10s %-6s %-8s %-15s %-10s %-12s %-14s %-8s\n" \
          "$type" "$node" "$name" "$status" "${ip:0:30}" "$bridge" "$vlan" "$onboot" "$storage" "$disksize" "$vmid" "$tags" "$note"
      else
        printf "%-6s %-10s %-26s %-10s %-30s %-10s %-8s %-15s %-10s %-12s %-14s %-8s\n" \
          "$type" "$node" "$name" "$status" "${ip:0:30}" "$bridge" "$onboot" "$storage" "$disksize" "$vmid" "$tags" "$note"
      fi
    done < "${TMP_DATA}.sorted"

    rm -f "$TMP_DATA" "${TMP_DATA}.sorted"
    rm -rf "$CACHE_DIR"
  }

  # Get PVE versions forall nodes in cluster 
  proxmox_nodes_get_version() {
    for n in $(pvesh get /nodes --output-format json | jq -r '.[].node'); do
        echo -n "$n: "
        pvesh get /nodes/$n/version --output-format json | jq -r '.version'
    done
  }

  # Find out what is DM-X
  proxmox_dm_lvm_list() {
    lvdisplay|awk '/LV Name/{n=$3} /Block device/{d=$3; sub(".*:","dm-",d); print d,n;}'
  }  

  # Disable auto-start all:
  proxmox_disable_all_autostart() {
    echo "Disabling 'onboot' for all LXC containers..."
    for CTID in $(pct list | awk 'NR>1 {print $1}'); do
      pct set $CTID --onboot 0
    done

    echo "Disabling 'onboot' for all KVM virtual machines..."
    for VMID in $(qm list | awk 'NR>1 {print $1}'); do
      qm set $VMID --onboot 0
    done
  }

  # Enable auto-start all:
  proxmox_enable_all_autostart() {
    # Enable autostart for all:
    echo "Enabling 'onboot' for all LXC containers..."
    for CTID in $(pct list | awk 'NR>1 {print $1}'); do
      pct set $CTID --onboot 1
    done

    echo "Enabling 'onboot' for all KVM virtual machines..."
    for VMID in $(qm list | awk 'NR>1 {print $1}'); do
      qm set $VMID --onboot 1
    done
  }
#######################

### HAproxy ###########
  haproxy_top_ip-conn-day() {
    local LOGDIR="/var/log"
    local FILES=$(ls $LOGDIR/haproxy.log*)

    zcat -f $FILES |
      awk '
  {
    # Extract IP (before colon)
    match($0, /^.*haproxy\[[0-9]+\]: ([^:]+):[0-9]+/, ip)
    # Extract date from request time
    match($0, /\[([0-9]+)\/([A-Za-z]+)\/([0-9]{4})/, dt)
    if (ip[1] != "" && dt[1] != "" && dt[2] != "" && dt[3] != "") {
      # Format date as YYYY-MM-DD
      months["Jan"]="01"; months["Feb"]="02"; months["Mar"]="03"; months["Apr"]="04";
      months["May"]="05"; months["Jun"]="06"; months["Jul"]="07"; months["Aug"]="08";
      months["Sep"]="09"; months["Oct"]="10"; months["Nov"]="11"; months["Dec"]="12";
      day = dt[1]; mon = months[dt[2]]; year = dt[3];
      printf("%s %s\n", year "-" mon "-" day, ip[1]);
    }
  }' | sort | uniq -c | sort -k2,2 -k1,1nr |
      awk '
  {
    count[$2][$3] = $1
  }
  END {
    PROCINFO["sorted_in"] = "@ind_str_asc"
    for (day in count) {
      print "==== Top 10 IPs for " day " ===="
      n = 0
      for (ip in count[day]) {
        printf "%s - %s connections\n", ip, count[day][ip]
        n++
        if (n == 10) break
      }
      print ""
    }
  }'
  }

#######################

### Nginx #############

  nginx_top_ip-conn-day() {

    local tmpfile=$(mktemp)

    for file in /var/log/nginx/*access.log*; do
      if [[ $file == *.gz ]]; then
        zcat "$file"
      else
        cat "$file"
      fi | awk -v logfile="$file" '
      {
          ip = $1
          match($4, /\[([0-9]{2}\/[A-Za-z]{3}\/[0-9]{4})/, m)
          date = m[1]
          if (ip != "" && date != "") {
              key = date "|" ip
              count[key]++
              filemap[key] = logfile
          }
      }
      END {
          for (k in count) {
              split(k, parts, "|")
              date = parts[1]
              ip = parts[2]
              printf "%s|%s|%d|%s\n", date, ip, count[k], filemap[k]
          }
      }'
    done >"$tmpfile"

    cut -d'|' -f1 "$tmpfile" | sort | uniq | while read date; do
      echo "Date: $date"
      grep "^$date|" "$tmpfile" | sort -t'|' -k3,3nr | head -n 25 | awk -F'|' '{printf "\t%s\t%s\t%s\n", $2, $3, $4}'
    done

    rm "$tmpfile"
  }

  nginx_top_ip_country-conn-day() {
    awk '{print $1, $2}' /var/log/nginx/*access.log | sort | uniq -c | sort -nr | head -n 20 | while read count ip host path; do country=$(geoiplookup "$ip" | awk -F ': ' '{print $2}'); printf "%7s %-15s %-30s %-20s %s\n" "$count" "$ip" "$host" "$country"; done
  }
  
  nginx_top_ip_country-conn-day-json() {
    echo "["

    first=1

    awk '{print $1, $2}' /var/log/nginx/*access.log | sort | uniq -c | sort -nr | head -n 20 | while read count ip host; do
        country=$(geoiplookup "$ip" | awk -F ': ' '{print $2}' | sed 's/"/\\"/g')
        
        if [ "$first" -eq 0 ]; then
            echo ","
        fi

        printf '  {\n'
        printf '    "ip": "%s",\n' "$ip"
        printf '    "host": "%s",\n' "$host"
        printf '    "count": %s,\n' "$count"
        printf '    "country": "%s"\n' "$country"
        printf '  }'

        first=0
    done

    echo
    echo "]"
  }

  nginx_top_ip-conn() {
    awk '{print $1}' /var/log/nginx/*access.log | sort | uniq -c | sort -nr | head -20
  }

  nginx_most_requested_url_last_hour() {
    grep "$(date --date='1 hour ago' "+%d/%b/%Y:%H")" /var/log/nginx/*_access.log | awk '{print $1, $7, $9}' | sort | uniq -c | sort -nr | head -20
  }

  nginx_errors_count_last_hour() {
    grep "$(date --date='1 hour ago' "+%Y/%m/%d %H")" /var/log/nginx/*_error.log | sort | uniq -c | sort -nr | head -20
  }
#######################

### scanner ###########
  # quick scan:
  nmap_quick() {
    if [[ -z "$1" ]]; then
      echo "Usage: nmap_quick <target>"
      echo "Usage: nmap_quick <target> <port>"
      return 1
    fi

    if ! command -v nmap >/dev/null 2>&1; then
      echo "Error: nmap command not found. Please install nmap." >&2
      return 1
    fi

    if [[ -n "$2" ]]; then
      echo "${LGREEN}Scanning ${YELLOW}$2${LGREEN} port in ${YELLOW}$1"
      nmap -sV --script=banner -p"$2" --min-parallelism 100 --max-parallelism 256 --max-retries 1  -oG - "$1" | grep -v "Up\|closed\|filtered" 
    else
      echo "${LGREEN}Scanning all hosts in ${YELLOW}$1"
      nmap -sn --min-parallelism 100 --max-parallelism 256 --max-retries 1 -T5 -oG - "$1" 
    fi
  }

#######################

### ZFS ###############
  # Get ARC stats
  zfs_arc_stats() {
    awk '
    BEGIN {
        printf "%-24s %-18s %s\n", "Metric", "Size", "Description";
        printf "%-24s %-18s %s\n", "------", "--------------", "-----------";
    }

    # helper: print bytes as GiB
    function gib(x) {
        return sprintf("%.2f GiB", x/1024/1024/1024);
    }

    $1=="size" {
        printf "%-24s %-18s %s\n", "ARC size", gib($3), "Current ARC usage";
    }

    $1=="c_min" {
        printf "%-24s %-18s %s\n", "c_min", gib($3), "Minimum ARC target";
    }

    $1=="c" {
        printf "%-24s %-18s %s\n", "c (target)", gib($3), "Current ARC target size";
    }

    $1=="c_max" {
        printf "%-24s %-18s %s\n", "c_max", gib($3), "Maximum ARC limit";
    }

    $1=="data_size" {
        printf "%-24s %-18s %s\n", "data_size", gib($3), "Data portion stored in ARC";
    }

    $1=="dnode_size" {
        printf "%-24s %-18s %s\n", "dnode_size", gib($3), "DNODE metadata footprint";
    }

    $1=="memory_all_bytes" {
        printf "%-24s %-18s %s\n", "memory_all_bytes", gib($3), "Total system memory";
    }

    $1=="memory_free_bytes" {
        printf "%-24s %-18s %s\n", "memory_free_bytes", gib($3), "Free memory at the moment";
    }

    $1=="memory_available_bytes" {
        printf "%-24s %-18s %s\n", "memory_available_bytes", gib($3), "Available memory (OS estimate)";
    }

    $1=="arc_no_grow" {
        printf "%-24s %-18d %s\n", "arc_no_grow", $3, "1 means ARC growth is blocked";
    }

    $1=="arc_prune" {
        printf "%-24s %-18d %s\n", "arc_prune", $3, "ARC eviction/pruning events";
    }

    $1=="arc_dnode_limit" {
        printf "%-24s %-18s %s\n", "arc_dnode_limit", gib($3), "Limit on DNODE caching inside ARC";
    }

    $1=="arc_need_free" {
        printf "%-24s %-18s %s\n", "arc_need_free", gib($3), "Memory ARC wants the system to free";
    }

    $1=="arc_sys_free" {
        printf "%-24s %-18s %s\n", "arc_sys_free", gib($3), "System memory threshold used by ARC";
    }
    ' /proc/spl/kstat/zfs/arcstats
  }

#######################

###################################
